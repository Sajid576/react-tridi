{"ast":null,"code":"var NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\nfunction C(aA1) {\n  return 3.0 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  var currentX,\n    currentT,\n    i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x;\n    }\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};","map":{"version":3,"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","newtonRaphsonIterate","aGuessT","currentSlope","module","exports","bezier","mY1","mY2","Error","sampleValues","Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope","BezierEasing","x"],"sources":["/home/sajid/Desktop/WorkSpace/carniba/workspace/reactTridi/react-tridi/example/node_modules/animated/lib/bezier.js"],"sourcesContent":["\n\n\n\n\n\n\n\nvar NEWTON_ITERATIONS=4;\nvar NEWTON_MIN_SLOPE=0.001;\nvar SUBDIVISION_PRECISION=0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS=10;\n\nvar kSplineTableSize=11;\nvar kSampleStepSize=1.0/(kSplineTableSize-1.0);\n\nvar float32ArraySupported=typeof Float32Array==='function';\n\nfunction A(aA1,aA2){return 1.0-3.0*aA2+3.0*aA1;}\nfunction B(aA1,aA2){return 3.0*aA2-6.0*aA1;}\nfunction C(aA1){return 3.0*aA1;}\n\n\nfunction calcBezier(aT,aA1,aA2){return((A(aA1,aA2)*aT+B(aA1,aA2))*aT+C(aA1))*aT;}\n\n\nfunction getSlope(aT,aA1,aA2){return 3.0*A(aA1,aA2)*aT*aT+2.0*B(aA1,aA2)*aT+C(aA1);}\n\nfunction binarySubdivide(aX,aA,aB,mX1,mX2){\nvar currentX,currentT,i=0;\ndo{\ncurrentT=aA+(aB-aA)/2.0;\ncurrentX=calcBezier(currentT,mX1,mX2)-aX;\nif(currentX>0.0){\naB=currentT;\n}else{\naA=currentT;\n}\n}while(Math.abs(currentX)>SUBDIVISION_PRECISION&&++i<SUBDIVISION_MAX_ITERATIONS);\nreturn currentT;\n}\n\nfunction newtonRaphsonIterate(aX,aGuessT,mX1,mX2){\nfor(var i=0;i<NEWTON_ITERATIONS;++i){\nvar currentSlope=getSlope(aGuessT,mX1,mX2);\nif(currentSlope===0.0){\nreturn aGuessT;\n}\nvar currentX=calcBezier(aGuessT,mX1,mX2)-aX;\naGuessT-=currentX/currentSlope;\n}\nreturn aGuessT;\n}\n\nmodule.exports=function bezier(mX1,mY1,mX2,mY2){\nif(!(0<=mX1&&mX1<=1&&0<=mX2&&mX2<=1)){\nthrow new Error('bezier x values must be in [0, 1] range');\n}\n\n\nvar sampleValues=float32ArraySupported?new Float32Array(kSplineTableSize):new Array(kSplineTableSize);\nif(mX1!==mY1||mX2!==mY2){\nfor(var i=0;i<kSplineTableSize;++i){\nsampleValues[i]=calcBezier(i*kSampleStepSize,mX1,mX2);\n}\n}\n\nfunction getTForX(aX){\nvar intervalStart=0.0;\nvar currentSample=1;\nvar lastSample=kSplineTableSize-1;\n\nfor(;currentSample!==lastSample&&sampleValues[currentSample]<=aX;++currentSample){\nintervalStart+=kSampleStepSize;\n}\n--currentSample;\n\n\nvar dist=(aX-sampleValues[currentSample])/(sampleValues[currentSample+1]-sampleValues[currentSample]);\nvar guessForT=intervalStart+dist*kSampleStepSize;\n\nvar initialSlope=getSlope(guessForT,mX1,mX2);\nif(initialSlope>=NEWTON_MIN_SLOPE){\nreturn newtonRaphsonIterate(aX,guessForT,mX1,mX2);\n}else if(initialSlope===0.0){\nreturn guessForT;\n}else{\nreturn binarySubdivide(aX,intervalStart,intervalStart+kSampleStepSize,mX1,mX2);\n}\n}\n\nreturn function BezierEasing(x){\nif(mX1===mY1&&mX2===mY2){\nreturn x;\n}\n\nif(x===0){\nreturn 0;\n}\nif(x===1){\nreturn 1;\n}\nreturn calcBezier(getTForX(x),mY1,mY2);\n};\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}